--Taller 2.2 en motores: PostgreSQL y MySQL
--MySQL ------------------------------------------------------------------------
--Script del power designer:

CREATE DATABASE IF NOT EXISTS taller_indices
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_unicode_ci;

USE taller_indices;

SET FOREIGN_KEY_CHECKS = 0;

DROP TRIGGER IF EXISTS TDB_BODEGA;
DROP TRIGGER IF EXISTS TUB_BODEGA;
DROP TRIGGER IF EXISTS TDB_PRODUCTO;
DROP TRIGGER IF EXISTS TUB_PRODUCTO;
DROP TRIGGER IF EXISTS TIB_PRODUTO_BODEGA;
DROP TRIGGER IF EXISTS TUB_PRODUTO_BODEGA;

DROP TABLE IF EXISTS PRODUCTO_BODEGA;
DROP TABLE IF EXISTS PRODUCTO;
DROP TABLE IF EXISTS BODEGA;

SET FOREIGN_KEY_CHECKS = 1;

CREATE TABLE BODEGA (
   BOD_CODIGO      VARCHAR(4)  NOT NULL COMMENT '',
   BOD_DESCRIPCION VARCHAR(60)     NULL COMMENT '',
   PRIMARY KEY (BOD_CODIGO)
) ENGINE = InnoDB
  COMMENT = 'Entidad que almacena información de la bodega.';

CREATE TABLE PRODUCTO (
   PRD_CODIGO      VARCHAR(12)  NOT NULL COMMENT '',
   PRD_DESCRIPCION VARCHAR(60)      NULL COMMENT '',
   PRD_PRECIO      DECIMAL(8,2)     NULL COMMENT '',
   PRIMARY KEY (PRD_CODIGO)
) ENGINE = InnoDB
  COMMENT = 'Entidad que almacena los productos.';

CREATE TABLE PRODUCTO_BODEGA (
   PRD_CODIGO     VARCHAR(12)  NOT NULL COMMENT '',
   BOD_CODIGO     VARCHAR(4)   NOT NULL COMMENT '',
   PRB_EXISTENCIA DECIMAL(10,2)     NULL COMMENT '',
   PRIMARY KEY (PRD_CODIGO, BOD_CODIGO),
   CONSTRAINT FK_PB_PRODUCTO FOREIGN KEY (PRD_CODIGO)
       REFERENCES PRODUCTO (PRD_CODIGO),
   CONSTRAINT FK_PB_BODEGA FOREIGN KEY (BOD_CODIGO)
       REFERENCES BODEGA (BOD_CODIGO)
) ENGINE = InnoDB
  COMMENT = 'Entidad que almacena información del producto y bodega.';

DELIMITER $$

CREATE TRIGGER TDB_BODEGA
BEFORE DELETE ON BODEGA
FOR EACH ROW
BEGIN
END$$

CREATE TRIGGER TUB_BODEGA
BEFORE UPDATE ON BODEGA
FOR EACH ROW
BEGIN
END$$

CREATE TRIGGER TDB_PRODUCTO
BEFORE DELETE ON PRODUCTO
FOR EACH ROW
BEGIN
END$$

CREATE TRIGGER TUB_PRODUCTO
BEFORE UPDATE ON PRODUCTO
FOR EACH ROW
BEGIN
END$$

CREATE TRIGGER TIB_PRODUTO_BODEGA
BEFORE INSERT ON PRODUCTO_BODEGA
FOR EACH ROW
BEGIN
END$$

CREATE TRIGGER TUB_PRODUTO_BODEGA
BEFORE UPDATE ON PRODUCTO_BODEGA
FOR EACH ROW
BEGIN
END$$

DELIMITER ;



INSERT INTO BODEGA (BOD_CODIGO, BOD_DESCRIPCION) VALUES
('B001', 'Bodega 1'),
('B002', 'Bodega 2'),
('B003', 'Bodega 3'),
('B004', 'Bodega 4'),
('B005', 'Bodega 5'),
('B006', 'Bodega 6'),
('B007', 'Bodega 7'),
('B008', 'Bodega 8'),
('B009', 'Bodega 9'),
('B010', 'Bodega 10');


INSERT INTO PRODUCTO (PRD_CODIGO, PRD_DESCRIPCION, PRD_PRECIO)
SELECT CONCAT('PRD', LPAD(a.n, 4, '0')) AS PRD_CODIGO, CONCAT('Producto ', a.n) AS PRD_DESCRIPCION, ROUND(RAND()*490 + 10, 2) AS PRD_PRECIO
FROM (
    SELECT @row := @row + 1 AS n
    FROM information_schema.columns, (SELECT @row := 0) AS x
    LIMIT 1000
) AS a;



INSERT INTO PRODUCTO_BODEGA (PRD_CODIGO, BOD_CODIGO, PRB_EXISTENCIA)
SELECT CONCAT('PRD', LPAD(a.n, 4, '0')) AS PRD_CODIGO,  CONCAT('B', LPAD(((a.n - 1) MOD 10) + 1, 3, '0')) AS BOD_CODIGO, ROUND(RAND()*500, 2) AS PRB_EXISTENCIA
FROM (
    SELECT @row2 := @row2 + 1 AS n
    FROM information_schema.columns, (SELECT @row2 := 0) AS x
    LIMIT 1000
) AS a;


SELECT COUNT(*) FROM PRODUCTO;
SELECT COUNT(*) FROM PRODUCTO_BODEGA;
SELECT COUNT(*) FROM BODEGA;

-- 1 Consulta general
SELECT  p.PRD_CODIGO, p.PRD_DESCRIPCION, p.PRD_PRECIO, b.BOD_CODIGO, b.BOD_DESCRIPCION, pb.PRB_EXISTENCIA
FROM PRODUCTO p
JOIN PRODUCTO_BODEGA pb ON p.PRD_CODIGO = pb.PRD_CODIGO
JOIN BODEGA b ON b.BOD_CODIGO = pb.BOD_CODIGO;

-- 2. Plan estimación
EXPLAIN
SELECT  p.PRD_CODIGO, p.PRD_DESCRIPCION, p.PRD_PRECIO, b.BOD_CODIGO, b.BOD_DESCRIPCION, pb.PRB_EXISTENCIA
FROM PRODUCTO p
JOIN PRODUCTO_BODEGA pb ON p.PRD_CODIGO = pb.PRD_CODIGO
JOIN BODEGA b ON b.BOD_CODIGO = pb.BOD_CODIGO;

-- Plan con tiempos reales
EXPLAIN ANALYZE
SELECT  p.PRD_CODIGO, p.PRD_DESCRIPCION, p.PRD_PRECIO,  b.BOD_CODIGO, b.BOD_DESCRIPCION,  pb.PRB_EXISTENCIA
FROM PRODUCTO p
JOIN PRODUCTO_BODEGA pb ON p.PRD_CODIGO = pb.PRD_CODIGO
JOIN BODEGA b ON b.BOD_CODIGO = pb.BOD_CODIGO;

-- 2. Consulta de bodega 1
SELECT  p.PRD_CODIGO, p.PRD_DESCRIPCION, p.PRD_PRECIO,  b.BOD_CODIGO, b.BOD_DESCRIPCION, pb.PRB_EXISTENCIA
FROM PRODUCTO p
JOIN PRODUCTO_BODEGA pb ON p.PRD_CODIGO = pb.PRD_CODIGO
JOIN BODEGA b ON b.BOD_CODIGO = pb.BOD_CODIGO
WHERE b.BOD_DESCRIPCION = 'Bodega 1';

-- Plan estimado con consulta específica
EXPLAIN
SELECT  p.PRD_CODIGO, p.PRD_DESCRIPCION, p.PRD_PRECIO, b.BOD_CODIGO, b.BOD_DESCRIPCION, pb.PRB_EXISTENCIA
FROM PRODUCTO p
JOIN PRODUCTO_BODEGA pb ON p.PRD_CODIGO = pb.PRD_CODIGO
JOIN BODEGA b ON b.BOD_CODIGO = pb.BOD_CODIGO
WHERE b.BOD_DESCRIPCION = 'Bodega 1';

-- 3. Filas recuperadas por la consulta
SELECT COUNT(*) AS filas_recuperadas
FROM PRODUCTO p
JOIN PRODUCTO_BODEGA pb ON p.PRD_CODIGO = pb.PRD_CODIGO
JOIN BODEGA b ON b.BOD_CODIGO = pb.BOD_CODIGO
WHERE b.BOD_DESCRIPCION = 'Bodega 1';

-- 4. Estadísticas de tablas filas estimadas y tamaño en bytes
SELECT 
    TABLE_NAME,
    TABLE_ROWS,           -- filas aproximadas
    DATA_LENGTH,          -- bytes de datos
    INDEX_LENGTH          -- bytes de índices
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_NAME IN ('PRODUCTO', 'BODEGA', 'PRODUCTO_BODEGA');

SELECT 
    TABLE_ROWS,
    DATA_LENGTH,
    DATA_LENGTH / 16384 AS blocks_aprox
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_NAME = 'PRODUCTO_BODEGA';


-- 5. Proporción de filas y bloques leídos para la consulta específica
SELECT
    sel.filas_recuperadas,
    stats.TABLE_ROWS       AS num_rows_est,
    stats.DATA_LENGTH / 16384 AS blocks_aprox,
    sel.filas_recuperadas / stats.TABLE_ROWS          AS proporcion_filas,
    (sel.filas_recuperadas / stats.TABLE_ROWS) * (stats.DATA_LENGTH / 16384)
        AS bloques_leidos_b
FROM
(
    SELECT COUNT(*) AS filas_recuperadas
    FROM PRODUCTO p
    JOIN PRODUCTO_BODEGA pb ON p.PRD_CODIGO = pb.PRD_CODIGO
    JOIN BODEGA b           ON b.BOD_CODIGO = pb.BOD_CODIGO
    WHERE b.BOD_DESCRIPCION = 'Bodega 1'
) sel,
(
    SELECT TABLE_ROWS, DATA_LENGTH
    FROM INFORMATION_SCHEMA.TABLES
    WHERE TABLE_SCHEMA = DATABASE()
      AND TABLE_NAME = 'PRODUCTO_BODEGA'
) stats;


-- 6. tT: tiempo estimado de leer con 1 ms por bloque
SELECT
    DATA_LENGTH /16384 AS blocks_aprox,
    (DATA_LENGTH /16384)*1.0 AS tT_ms
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_NAME = 'PRODUCTO_BODEGA';

-- tS: tiempo estimado para el índice de PRODUCTO
SELECT
    INDEX_LENGTH / 16384 AS index_blocks_aprox,
    (INDEX_LENGTH /16384) *1.0 AS tS_ms
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_NAME = 'PRODUCTO';

-- 5. Proporción de filas y bloques leídos (b) para la consulta específica
SELECT
    100.0                    AS filas_recuperadas,     -- son 100
    1000.0                   AS num_rows_est,          -- TABLE_ROWS de PRODUCTO_BODEGA
    4.0                      AS blocks_aprox,          -- DATA_LENGTH / 16384
    100.0 / 1000.0           AS proporcion_filas,
    (100.0 / 1000.0) * 4.0   AS bloques_leidos_b;
